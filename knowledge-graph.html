<!DOCTYPE html>
<!-- 页面：知识图谱（城市轨道交通运营管理） -->
<!-- 结构：导航栏 / 知识图谱可视化区域 -->
<!-- 功能：显示知识图谱，支持搜索和交互功能 -->
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>知识图谱</title>
    <!-- 引入 vis.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <!-- 页面样式：全局重置、导航、图谱容器 -->
    <style>
      /* 全局样式重置 */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: #333;
        background-color: #f9f9f9;
        overflow: hidden; /* 防止页面滚动 */
      }

      /* 导航栏样式 */
      nav {
        background-color: #2c3e50;
        padding: 15px 20px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        position: relative;
        z-index: 10;
      }

      nav ul {
        list-style-type: none;
        display: flex;
        margin: 0;
        padding: 0;
      }

      nav ul li {
        margin-right: 20px;
        display: flex;
        align-items: center;
      }

      nav ul li a {
        color: white;
        text-decoration: none;
        padding: 8px 12px;
        border-radius: 4px;
        transition: background-color 0.3s ease, color 0.3s ease;
        display: inline-block;
        line-height: normal;
      }

      nav ul li a:hover {
        background-color: #34495e;
        color: #f1c40f;
      }

      .nav-right {
        margin-left: auto;
      }

      .user-info {
        display: none; /* 默认隐藏用户信息 */
      }

      .user-info a {
        display: inline-block;
        vertical-align: middle;
      }

      .user-info.active {
        display: block;
      }

      /* 搜索区域样式 */
      .search-container {
        position: absolute;
        top: 80px;
        left: 20px;
        z-index: 5;
        background: white;
        border-radius: 4px;
        padding: 10px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        gap: 10px;
        width: 300px;
      }

      .search-container input {
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        width: 100%;
      }

      .search-container button {
        background-color: #2c3e50;
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .search-container button:hover {
        background-color: #34495e;
      }

      .layout-container {
        margin-top: 10px;
      }

      .layout-container select {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 12px;
      }

      /* 状态信息 */
      .status-message {
        margin-top: 10px;
        padding: 8px;
        border-radius: 4px;
        font-size: 12px;
        display: none;
      }

      .status-success {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }

      .status-error {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }

      .status-warning {
        background-color: #fff3cd;
        color: #856404;
        border: 1px solid #ffeeba;
      }

      /* 图谱容器 - 占满导航栏下的所有空间 */
      #knowledge-graph-container {
        position: absolute;
        top: 54px; /* 导航栏高度 */
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        background-color: #f9f9f9;
      }

      /* 响应式设计 */
      @media (max-width: 1200px) {
        nav ul {
          flex-direction: column;
          align-items: center;
        }

        nav ul li {
          margin: 10px 0;
        }

        .search-container {
          width: calc(100% - 40px);
          top: 60px;
        }
      }
    </style>
  </head>
  <body>
    <!-- 导航栏 -->
    <nav>
      <ul class="nav-left">
        <li><a href="index.html">首页</a></li>
        <li><a href="./knowledge-graph.html">知识图谱</a></li>
        <li><a href="./aiqa.html">AI问答</a></li>
        <li><a href="./test.html">知识测试</a></li>
        <li><a href="./resources.html">课程资源</a></li>
      </ul>
      <ul class="nav-right">
        <li class="user-info" id="user-info">
          <a href="./user-center.html" id="user-link">欢迎，<span id="username"></span></a>
        </li>
        <li>
          <a href="javascript:void(0)" onclick="logout()" id="logout-link">退出</a>
        </li>
        <li><a href="./login.html" id="login-link">登录</a></li>
        <li><a href="./register.html" id="register-link">注册</a></li>
      </ul>
    </nav>

    <!-- 搜索区域 -->
    <div class="search-container">
      <input type="text" id="search-node" placeholder="搜索知识节点..." />
      <button id="search-button">搜索</button>

      <!-- 布局选择区域 -->
      <div class="layout-container">
        <label for="layout-select">布局</label>
        <select id="layout-select">
          <option value="hierarchical">层次结构</option>
          <option value="forceAtlas2">力导向(ForceAtlas2)</option>
          <option value="barnesHut">Barnes-Hut</option>
          <option value="repulsion" selected>排斥布局</option>
          <option value="none">无物理(静态)</option>
        </select>
      </div>

      <!-- 状态信息 -->
      <div id="status-message" class="status-message"></div>
    </div>

    <!-- 知识图谱容器 - 占满整个屏幕 -->
    <div id="knowledge-graph-container"></div>

    <!-- 页面脚本 -->
    <script>
      // 检查登录状态
      async function checkLogin() {
        try {
          // 从localStorage获取用户信息
          const userInfoStr = localStorage.getItem("userInfo");

          const userInfo = document.getElementById("user-info");
          const logoutLink = document.getElementById("logout-link");
          const loginLink = document.getElementById("login-link");
          const registerLink = document.getElementById("register-link");

          if (userInfoStr) {
            // 解析用户信息
            const user = JSON.parse(userInfoStr);

            // 显示用户信息
            document.getElementById("username").textContent = user.name;

            // 更新UI显示状态
            userInfo.style.display = "block";
            logoutLink.style.display = "block";
            loginLink.style.display = "none";
            registerLink.style.display = "none";
          } else {
            // 用户未登录
            userInfo.style.display = "none";
            logoutLink.style.display = "none";
            loginLink.style.display = "block";
            registerLink.style.display = "block";
          }
        } catch (error) {
          console.error("检查登录状态失败:", error);
        }
      }

      // 退出功能
      async function logout() {
        // 从localStorage中移除用户信息
        localStorage.removeItem("userInfo");

        // 刷新页面
        window.location.reload();
      }

      // 全局变量
      let graphNetwork = null;
      let physicsFrozen = false;

      // 获取当前网络
      function getCurrentNetwork() {
        return graphNetwork;
      }

      // 统一的网络处理函数：设置节点标题和边关系类型
      function setupNetwork(network) {
        if (!network?.body?.data) return;

        try {
          // 1. 更新节点标题
          const nodeDs = network.body.data.nodes;
          const edgeDs = network.body.data.edges;
          const nodes = nodeDs.get();
          const edges = edgeDs.get();

          // 设置节点标题格式
          nodeDs.update(nodes.map(n => ({
            id: n.id,
            title: [n.label, n.group].filter(Boolean).join(" / ")
          })));

          // 2. 提取所有关系类型并统一更新边的样式和标签
          const edgeUpdates = edges.map(e => ({
            id: e.id,
            label: e.type || e.relationshipType || "",
            title: e.type || e.relationshipType || "关系",
            // 统一样式
            color: { color: "#999999", highlight: "#666666", inherit: false },
            width: 1.5,
            arrows: { to: { enabled: true, scaleFactor: 1.2 } },
            font: {
              align: "middle",
              size: 14,
              color: "#777777",
              background: "rgba(255,255,255,0.85)"
            }
          }));

          // 批量更新
          edgeDs.update(edgeUpdates);
        } catch (error) {
          console.error("设置网络属性时出错:", error);
        }
      }

      // 应用布局预设
      function applyLayoutPreset(preset) {
        const network = getCurrentNetwork();
        if (!network) return;

        physicsFrozen = false;
        let options = {};

        if (preset === "hierarchical") {
          options = {
            layout: {
              hierarchical: {
                enabled: true,
                direction: "LR",
                sortMethod: "hubsize",
                nodeSpacing: 120,
                levelSeparation: 180
              }
            },
            physics: {
              enabled: true,
              solver: "hierarchicalRepulsion",
              hierarchicalRepulsion: {
                nodeDistance: 170,
                springLength: 120,
                springConstant: 0.01,
                damping: 0.9
              },
              minVelocity: 0.75,
              stabilization: {
                enabled: true,
                iterations: 300,
                updateInterval: 50
              }
            }
          };
        } else if (preset === "forceAtlas2") {
          options = {
            layout: {
              improvedLayout: true,
              hierarchical: { enabled: false }
            },
            physics: {
              enabled: true,
              solver: "forceAtlas2Based",
              forceAtlas2Based: {
                gravitationalConstant: -200,
                centralGravity: 0.06,
                springLength: 260,
                springConstant: 0.035,
                damping: 0.9,
                avoidOverlap: 1
              },
              minVelocity: 0.75,
              stabilization: {
                enabled: true,
                iterations: 800,
                updateInterval: 100
              }
            }
          };
        } else if (preset === "barnesHut") {
          options = {
            layout: { hierarchical: { enabled: false } },
            physics: {
              enabled: true,
              solver: "barnesHut",
              barnesHut: {
                gravitationalConstant: -2000,
                centralGravity: 0.3,
                springLength: 150,
                springConstant: 0.05,
                damping: 0.9,
                avoidOverlap: 1
              },
              minVelocity: 0.75,
              stabilization: {
                enabled: true,
                iterations: 600,
                updateInterval: 80
              }
            }
          };
        } else if (preset === "repulsion") {
          options = {
            layout: { hierarchical: { enabled: false } },
            physics: {
              enabled: true,
              solver: "repulsion",
              repulsion: {
                nodeDistance: 300,
                springLength: 240,
                springConstant: 0.05,
                damping: 0.9
              },
              minVelocity: 0.7,
              stabilization: {
                enabled: true,
                iterations: 500,
                updateInterval: 80
              }
            }
          };
        } else if (preset === "none") {
          options = {
            layout: { hierarchical: { enabled: false } },
            physics: { enabled: false, stabilization: false }
          };
        }

        try {
          network.setOptions(options);
        } catch (err) {
          console.error("应用布局预设时出错:", err);
        }

        setPhysicsAutoFreeze(network, { enable: true });
        setupNetwork(network);
      }

      // 设置拖拽监听器
      function setupDragListeners(network) {
        if (!network) return;

        let draggedNode = null;
        let linkedNodes = null;
        let originalPositions = {};
        let isDragging = false;

        network.on("dragStart", params => {
          if (params.nodes && params.nodes.length > 0) {
            draggedNode = params.nodes[0];
            isDragging = true;

            // 获取与被拖拽节点直接相连的节点
            linkedNodes = network.getConnectedNodes(draggedNode);

            // 保存原始位置
            originalPositions = {};
            linkedNodes.forEach(nodeId => {
              const nodePosition = network.getPositions([nodeId])[nodeId];
              originalPositions[nodeId] = { ...nodePosition };
            });

            // 获取被拖拽节点的初始位置
            const dragNodePos = network.getPositions([draggedNode])[draggedNode];
            originalPositions[draggedNode] = { ...dragNodePos };
          }
        });

        network.on("dragging", params => {
          if (isDragging && draggedNode && linkedNodes && linkedNodes.length > 0) {
            // 获取被拖拽节点的当前位置
            const positions = network.getPositions([draggedNode]);
            const currentPos = positions[draggedNode];
            const originalPos = originalPositions[draggedNode];

            // 计算位移向量
            const dx = currentPos.x - originalPos.x;
            const dy = currentPos.y - originalPos.y;

            // 移动关联节点（跟随主节点移动，但位移较小）
            linkedNodes.forEach(nodeId => {
              if (originalPositions[nodeId]) {
                const origPos = originalPositions[nodeId];
                // 关联节点移动的比例（这里是50%的跟随移动）
                const followRatio = 0.5;
                network.moveNode(nodeId,
                  origPos.x + dx * followRatio,
                  origPos.y + dy * followRatio
                );
              }
            });
          }
        });

        network.on("dragEnd", params => {
          draggedNode = null;
          linkedNodes = null;
          originalPositions = {};
          isDragging = false;
        });
      }

      // 设置物理引擎自动冻结
      function setPhysicsAutoFreeze(network, { enable = true, stabilizeIterations = 800, maxWaitMs = 2000 } = {}) {
        if (physicsFrozen) {
          if (!network) {
            network = getCurrentNetwork();
          }
          if (!network) return;

          try {
            network.setOptions({ physics: { enabled: false, stabilization: false } });
          } catch (err) {
            console.error("设置物理引擎选项时出错:", err);
          }
          return;
        }

        if (!network) {
          network = getCurrentNetwork();
        }
        if (!network) return;

        const freeze = function() {
          physicsFrozen = true;
          try {
            if (typeof network.stopSimulation === "function") network.stopSimulation();
          } catch (err) {
            console.error("停止物理模拟时出错:", err);
          }

          try {
            network.setOptions({ physics: { enabled: false, stabilization: false } });
          } catch (err) {
            console.error("禁用物理引擎时出错:", err);
          }

          // 设置拖拽监听器
          setupDragListeners(network);
        };

        if (enable) {
          try {
            network.setOptions({ physics: { enabled: true } });
          } catch (err) {
            console.error("启用物理引擎时出错:", err);
          }

          try {
            network.stabilize(stabilizeIterations);
          } catch (err) {
            console.error("稳定化网络时出错:", err);
          }

          window.setTimeout(freeze, Math.max(500, maxWaitMs));
        }

        try {
          network.once("stabilizationIterationsDone", freeze);
        } catch (err) {
          console.error("设置稳定化完成监听器时出错:", err);
        }

        try {
          network.once("stabilized", freeze);
        } catch (err) {
          console.error("设置稳定化监听器时出错:", err);
        }
      }

      // 显示状态信息
      function showStatus(message, type) {
        const statusElement = document.getElementById('status-message');
        statusElement.textContent = message;
        statusElement.style.display = 'block';

        // 移除所有类
        statusElement.classList.remove('status-success', 'status-error', 'status-warning');

        // 添加对应类型的类
        if (type === 'success') {
          statusElement.classList.add('status-success');
        } else if (type === 'error') {
          statusElement.classList.add('status-error');
        } else if (type === 'warning') {
          statusElement.classList.add('status-warning');
        }

        // 5秒后自动隐藏（除非是错误消息）
        if (type !== 'error') {
          setTimeout(() => {
            statusElement.style.display = 'none';
          }, 5000);
        }
      }

      // 默认模拟数据（作为备用）
      const defaultData = {
        nodes: [
          { id: "1", labels: ["Chapter"], properties: { name: "绪论", chapterNumber: 1 } },
          { id: "2", labels: ["Chapter"], properties: { name: "城市轨道交通系统技术经济特征", chapterNumber: 2 } },
          { id: "3", labels: ["Chapter"], properties: { name: "列车运行和乘客出行的基本概念", chapterNumber: 3 } },
          { id: "101", labels: ["Concept"], properties: { name: "轨道交通特点" } },
          { id: "102", labels: ["Concept"], properties: { name: "运能指标" } },
          { id: "201", labels: ["Technique"], properties: { name: "能力计算方法" } },
          { id: "301", labels: ["Theory"], properties: { name: "追踪间隔理论" } }
        ],
        edges: [
          { id: "e1", from: "1", to: "2", type: "研究", properties: {} },
          { id: "e2", from: "2", to: "3", type: "具有", properties: {} },
          { id: "e3", from: "2", to: "101", type: "包含", properties: {} },
          { id: "e4", from: "3", to: "102", type: "包含", properties: {} },
          { id: "e5", from: "101", to: "201", type: "关联", properties: {} },
          { id: "e6", from: "201", to: "301", type: "依据", properties: {} }
        ]
      };

      // 实际使用的图谱数据
      let graphData = defaultData;

      // 从JSON文件加载数据
      async function loadDataFromJson() {
        const jsonFilePath = "./data/neo4j_query_table_data_2025-12-27.json";
        showStatus(`正在加载数据文件: ${jsonFilePath}...`, "warning");

        try {
          const response = await fetch(jsonFilePath);
          if (!response.ok) {
            throw new Error(`无法加载数据文件 (${response.status} ${response.statusText})`);
          }

          const jsonData = await response.json();
          showStatus(`成功加载数据文件，包含 ${jsonData.length} 条记录`, "success");
          console.log("加载的JSON数据样例:", JSON.stringify(jsonData[0]).substring(0, 300) + "...");

          // 转换数据为可视化所需的格式
          return convertJsonToVisFormat(jsonData);
        } catch (error) {
          console.error("加载JSON数据失败:", error);
          showStatus(`加载数据文件失败: ${error.message}。使用默认数据。`, "error");
          return defaultData;
        }
      };

      // 转换JSON数据为可视化所需的格式
      function convertJsonToVisFormat(jsonData) {
        console.log("开始转换图谱数据...");

        // 用于存储转换后的数据
        const visData = {
          nodes: [],
          edges: []
        };

        // 用于跟踪已处理的节点和关系，避免重复
        const processedNodes = new Map();
        const processedRelationships = new Map();

        // 处理所有记录
        jsonData.forEach((record, index) => {
          // 检查记录格式
          if (!record.p) {
            console.warn(`记录 #${index} 没有 'p' 属性，跳过`);
            return;
          }

          try {
            // 处理起始节点
            if (record.p.start) {
              const startNode = record.p.start;
              if (!processedNodes.has(startNode.identity)) {
                // 确定节点标签和颜色
                let nodeColor = "#97c2fc"; // 默认颜色
                let nodeGroup = "Node"; // 默认组别

                if (startNode.labels && startNode.labels.length > 0) {
                  nodeGroup = startNode.labels[0];
                  if (startNode.labels.includes("Concept")) {
                    nodeColor = "#fb7e81";
                    nodeGroup = "Concept";
                  } else if (startNode.labels.includes("Technique")) {
                    nodeColor = "#7be141";
                    nodeGroup = "Technique";
                  } else if (startNode.labels.includes("Theory")) {
                    nodeColor = "#ffff00";
                    nodeGroup = "Theory";
                  } else if (startNode.labels.includes("Chapter")) {
                    nodeColor = "#97c2fc";
                    nodeGroup = "Chapter";
                  }
                }

                // 添加节点
                visData.nodes.push({
                  id: startNode.identity.toString(),
                  label: startNode.properties.name || "未命名节点",
                  title: startNode.properties.name || "未命名节点",
                  group: nodeGroup,
                  color: nodeColor,
                  shape: "dot", // 使用圆形节点
                  font: { size: 16, face: "Arial", multi: "html" },
                  borderWidth: 2,
                  shadow: true,
                  properties: startNode.properties
                });

                // 标记为已处理
                processedNodes.set(startNode.identity, true);
              }
            }

            // 处理终点节点
            if (record.p.end) {
              const endNode = record.p.end;
              if (!processedNodes.has(endNode.identity)) {
                // 确定节点标签和颜色
                let nodeColor = "#97c2fc"; // 默认颜色
                let nodeGroup = "Node"; // 默认组别

                if (endNode.labels && endNode.labels.length > 0) {
                  nodeGroup = endNode.labels[0];
                  if (endNode.labels.includes("Concept")) {
                    nodeColor = "#fb7e81";
                    nodeGroup = "Concept";
                  } else if (endNode.labels.includes("Technique")) {
                    nodeColor = "#7be141";
                    nodeGroup = "Technique";
                  } else if (endNode.labels.includes("Theory")) {
                    nodeColor = "#ffff00";
                    nodeGroup = "Theory";
                  } else if (endNode.labels.includes("Chapter")) {
                    nodeColor = "#97c2fc";
                    nodeGroup = "Chapter";
                  }
                }

                // 添加节点
                visData.nodes.push({
                  id: endNode.identity.toString(),
                  label: endNode.properties.name || "未命名节点",
                  title: endNode.properties.name || "未命名节点",
                  group: nodeGroup,
                  color: nodeColor,
                  shape: "dot",
                  font: { size: 16, face: "Arial", multi: "html" },
                  borderWidth: 2,
                  shadow: true,
                  properties: endNode.properties
                });

                // 标记为已处理
                processedNodes.set(endNode.identity, true);
              }
            }

            // 处理段落中的关系
            if (record.p.segments && Array.isArray(record.p.segments)) {
              record.p.segments.forEach((segment, segIndex) => {
                if (segment.relationship) {
                  const rel = segment.relationship;

                  // 确保不重复添加同一关系
                  const relKey = `${rel.start}-${rel.end}-${rel.identity}`;
                  if (processedRelationships.has(relKey)) {
                    return;
                  }

                  // 添加边
                  visData.edges.push({
                    id: `e${index}_${segIndex}_${rel.identity}`,
                    from: rel.start.toString(),
                    to: rel.end.toString(),
                    type: rel.type,
                    label: rel.type,
                    title: rel.type,
                    relationshipId: rel.identity.toString(),
                    relationshipType: rel.type,
                    color: { color: "#999999", highlight: "#666666", inherit: false },
                    width: 1.5,
                    arrows: {
                      to: { enabled: true, scaleFactor: 1.2 }
                    },
                    font: {
                      align: "middle",
                      size: 14,
                      color: "#777777",
                      background: "rgba(255,255,255,0.85)",
                      strokeWidth: 2
                    },
                    smooth: {
                      type: "cubicBezier",
                      roundness: 0.3
                    },
                    properties: rel.properties || {}
                  });

                  // 标记为已处理
                  processedRelationships.set(relKey, true);
                }
              });
            }
          } catch (error) {
            console.error(`处理记录 #${index} 时出错:`, error);
          }
        });

        console.log(`转换完成，生成 ${visData.nodes.length} 个节点和 ${visData.edges.length} 条边`);
        return visData;
      };

      // 渲染图谱
      async function renderGraph() {
        showStatus("正在加载数据...", "warning");

        // 清空图谱容器
        const container = document.getElementById("knowledge-graph-container");
        container.innerHTML = "";

        try {
          // 加载数据
          graphData = await loadDataFromJson();
          showStatus(`数据加载成功 - 准备渲染 ${graphData.nodes.length} 个节点`, "success");
        } catch (error) {
          showStatus("数据加载失败 - 使用默认数据", "error");
          graphData = defaultData;
        }

        // 准备节点数据
        const nodes = new vis.DataSet(graphData.nodes.map(node => ({
          id: node.id || node.identity?.toString() || String(Math.random()),
          label: node.label || node.properties?.name || "未命名节点",
          title: node.title || node.properties?.name || "未命名节点",
          group: node.group || "Node",
          color: node.color || "#97c2fc",
          shape: node.shape || "dot",
          font: { size: 16, face: "Arial", multi: "html" },
          borderWidth: 2,
          shadow: true
        })));

        // 准备边数据
        const edges = new vis.DataSet(graphData.edges.map(edge => ({
          id: edge.id || String(Math.random()),
          from: edge.from,
          to: edge.to,
          label: edge.type || edge.label || "",
          title: edge.type || edge.label || "",
          type: edge.type || edge.label || "",
          relationshipType: edge.type || edge.label || "",
          color: { color: "#999999", highlight: "#666666", inherit: false },
          width: 1.5,
          arrows: { to: { enabled: true, scaleFactor: 1.2 } },
          font: {
            align: "middle",
            size: 14,
            color: "#777777",
            background: "rgba(255,255,255,0.85)"
          },
          smooth: { type: "cubicBezier", roundness: 0.3 }
        })));

        // 网络配置
        const options = {
          nodes: {
            shape: "dot",
            font: { size: 16, face: "Arial", multi: "html" },
            borderWidth: 2,
            shadow: true,
            scaling: { min: 16, max: 32, label: { enabled: true, min: 14, max: 24 } }
          },
          edges: {
            arrows: { to: { enabled: true, scaleFactor: 1.2 } },
            width: 1.5,
            color: { color: "#999999", highlight: "#666666", inherit: false },
            font: { size: 14, align: "middle", strokeWidth: 2, color: "#777777", background: "rgba(255,255,255,0.85)" },
            smooth: { type: "cubicBezier", roundness: 0.3 }
          },
          layout: { improvedLayout: true },
          physics: {
            enabled: true,
            solver: "forceAtlas2Based",
            forceAtlas2Based: {
              gravitationalConstant: -200,
              centralGravity: 0.06,
              springLength: 260,
              springConstant: 0.035,
              damping: 0.9,
              avoidOverlap: 1
            },
            minVelocity: 0.5,
            stabilization: { enabled: true, iterations: 1000, updateInterval: 50, fit: true }
          },
          interaction: {
            hover: true,
            navigationButtons: true,
            keyboard: { enabled: true },
            tooltipDelay: 200,
            hideEdgesOnDrag: false,
            zoomView: true
          }
        };

        // 创建网络
        graphNetwork = new vis.Network(container, { nodes, edges }, options);

        // 应用各种网络设置和优化
        setPhysicsAutoFreeze(graphNetwork, { enable: true, maxWaitMs: 3000 });
        setupNetwork(graphNetwork);
        setupDragListeners(graphNetwork);

        // 应用选择的布局预设
        const layoutSelectEl = document.getElementById("layout-select");
        if (layoutSelectEl) {
          applyLayoutPreset(layoutSelectEl.value || "repulsion");
        }
      }

      // 搜索节点
      function searchNodes(searchText) {
        if (!searchText.trim()) {
          showStatus("请输入要搜索的内容", "warning");
          return;
        }

        // 使用简单的前端过滤
        const filteredNodes = graphData.nodes.filter(node => {
          const nodeText = (node.properties?.title || node.properties?.name || node.label || "").toLowerCase();
          return nodeText.includes(searchText.toLowerCase());
        });

        if (filteredNodes.length > 0) {
          // 更新界面显示高亮搜索结果
          showStatus(`找到 ${filteredNodes.length} 个匹配节点`, "success");

          // 找到视图中的匹配节点
          const network = getCurrentNetwork();
          if (network) {
            try {
              // 高亮显示匹配的节点
              const nodeIds = filteredNodes.map(node => node.id);
              network.selectNodes(nodeIds);

              // 如果有匹配节点，将视图居中到第一个匹配节点
              if (nodeIds.length > 0) {
                network.focus(nodeIds[0], {
                  scale: 1.2,
                  animation: true
                });
              }
            } catch (err) {
              console.warn("高亮节点失败:", err);
            }
          }
        } else {
          showStatus("未找到匹配的节点", "warning");
        }
      }

      // 页面加载完成后初始化知识图谱
      window.onload = function() {
        // 检查登录状态
        checkLogin();

        // 显示图谱正在加载的状态
        showStatus("正在加载知识图谱数据...", "warning");

        // 渲染图谱
        renderGraph();

        // 搜索按钮事件监听
        document.getElementById("search-button").addEventListener("click", function() {
          const searchText = document.getElementById("search-node").value.trim();
          searchNodes(searchText);
        });

        // 布局选择器事件监听
        const layoutSelect = document.getElementById("layout-select");
        if (layoutSelect) {
          layoutSelect.addEventListener("change", function(e) {
            const preset = e.target.value;
            applyLayoutPreset(preset);
          });
        }

        // 回车键搜索
        document.getElementById("search-node").addEventListener("keypress", function(event) {
          if (event.key === "Enter") {
            document.getElementById("search-button").click();
          }
        });
      };
    </script>
  </body>
</html>